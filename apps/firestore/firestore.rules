rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }
    match /companies/{companyId} {
      allow get: if isSignedIn()
      && hasAtLeastOnePrivilegeOnCompany(companyId, ['company:read', 'company:write']);

      match /subscriptions/{subscriptionId} {
        allow read: if isSignedIn()
        && hasAtLeastOnePrivilegeOnCompany(companyId, ['subscriptions:read']);
      }

      match /transactions/{transactionId} {
        allow read: if isSignedIn()
        && hasAtLeastOnePrivilegeOnCompany(companyId, ['transactions:read', 'transactions:write']);
      }

      match /transactionCreateRequests/{transactionCreateRequestId} {
        allow create: if isSignedIn()
        && validCreateValues(incomingData())
        && isOwner(incomingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['transactions:write'])

        allow read: if isSignedIn()
        && isOwner(existingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['transactions:write']);

        function validCreateValues(incomingData) {
          return validDefaultCreationFields()
          && validRequestsCreationFields(incomingData)
          && incomingData.amount is number
          && (!('categoryId' in incomingData) || incomingData.categoryId is string )
          && incomingData.date is string
          && incomingData.description is string
          && incomingData.sourceType in ['financial-institution', 'user']
          && incomingData.sourceId is string && (incomingData.sourceType != 'user' || isOwner(incomingData.sourceId)) // second condition is to assure that the id is the user's id when the transaction is from the user
          && (!('sourceTransactionId' in incomingData) || incomingData.sourceTransactionId is string )
          && incomingData.type in ['credit', 'debit']
          && transactionId == null;
        }
      }

      match /transactionUpdateRequests/{transactionUpdateRequestId} {
        allow create: if isSignedIn()
        && validCreateValues(incomingData())
        && isOwner(incomingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['transactions:write'])

        allow read: if isSignedIn()
        && isOwner(existingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['transactions:write']);

        function validCreateValues(incomingData) {
          return validDefaultCreationFields(incomingData)
          && validRequestsCreationFields(incomingData)
          && (!('amount' in incomingData) || incomingData.amount is number )
          && (!('categoryId' in incomingData) || incomingData.categoryId is string )
          && (!('date' in incomingData) || incomingData.date is string )
          && (!('description' in incomingData) || incomingData.description is string )
          && (!('type' in incomingData) || incomingData.type in ['credit', 'debit'] );
        }
      }

      match /updateRequests/{updateRequestId} {
        allow create: if isSignedIn()
        && validCreateValues(incomingData())
        && isOwner(incomingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['company:write'])

        allow read: if isSignedIn()
        && isOwner(existingData().userId) && hasAtLeastOnePrivilegeOnCompany(companyId, ['company:write']);

        function validCreateValues(incomingData) {
          return validDefaultCreationFields(incomingData)
          && validRequestsCreationFields(incomingData)
          && (!('name' in incomingData) || incomingData.name is string );
        }
      }
    }
    function existingData() {
      return resource.data
    }
    function hasAtLeastOnePrivilegeOnCompany(companyId, privileges) {
      return request.auth.token.companies != null && request.auth.token.companies.keys().hasAny([companyId]) && request.auth.token.companies[companyId].hasAny(privileges);
    }
    function incomingData() {
      return request.resource.data
    }
    function isOwner(userId) {
      return request.auth.token.app_user_id == userId;
    }
    function isSignedIn() {
      return request.auth.uid != null;
    }
    function validDefaultCreationFields(incomingData) {
      return incomingData.keys().hasAny(['_onCreateEventId', '_onCreateMaxRetries', '_onCreateMaxRetriesReached', '_onCreateEventRetries']) == false
        && incomingData.createdAt == request.time && incomingData.updatedAt == request.time;
    }
    function validRequestsCreationFields(incomingData) {
      return incomingData.status == 'pending'
      && incomingData.error == null;
    }
    function validUpdateTimestamp(incomingData) {
      return incomingData.updatedAt == request.time && incomingData.createdAt == existingData.createdAt;
    }
  }
}